From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: PureGero <puregero@gmail.com>
Date: Sun, 28 Nov 2021 22:07:06 +1000
Subject: [PATCH] Hurt external entities


diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index bc7c2f1964302ddd779d465bb3dcfbc0c0ff7a4b..393b3227ca0693767244146220579922c432e0ee 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -142,8 +142,11 @@ import org.bukkit.event.player.PlayerItemConsumeEvent;
 // CraftBukkit end
 
 // Multipaper
+import puregero.multipaper.ExternalServerConnection;
 import puregero.multipaper.MultiPaper;
+import puregero.multipaper.MultiPaperEntityInteractHandler;
 import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
+import puregero.multipaper.externalserverprotocol.HurtEntityPacket;
 // Multipaper end
 
 public abstract class LivingEntity extends Entity implements Attackable {
@@ -1371,6 +1374,15 @@ public abstract class LivingEntity extends Entity implements Attackable {
 
     @Override
     public boolean hurt(DamageSource source, float amount) {
+        // MultiPaper start
+        ExternalServerConnection owner = MultiPaperEntityInteractHandler.getOwner(this);
+        if (owner != null) {
+            owner.send(new HurtEntityPacket(this, source, amount, CraftEventFactory.entityDamage, CraftEventFactory.blockDamage));
+            CraftEventFactory.entityDamage = null;
+            CraftEventFactory.blockDamage = null;
+            return false;
+        }
+        // MultiPaper end
         if (this.isInvulnerableTo(source)) {
             return false;
         } else if (this.level.isClientSide) {
diff --git a/src/main/java/puregero/multipaper/ExternalPlayer.java b/src/main/java/puregero/multipaper/ExternalPlayer.java
index fa9ca6c3c8d5a9eb983d399de7b9dd5574b40487..e4e39730f3c3e487e9066a49253089a6c276e03a 100644
--- a/src/main/java/puregero/multipaper/ExternalPlayer.java
+++ b/src/main/java/puregero/multipaper/ExternalPlayer.java
@@ -10,13 +10,16 @@ import net.minecraft.network.syncher.EntityDataAccessor;
 import net.minecraft.server.level.ServerLevel;
 import net.minecraft.server.level.ServerPlayer;
 import net.minecraft.server.network.ServerGamePacketListenerImpl;
+import net.minecraft.world.damagesource.DamageSource;
 import net.minecraft.world.level.GameType;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.bukkit.Bukkit;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
 import puregero.multipaper.externalserverprotocol.EntityUpdatePacket;
+import puregero.multipaper.externalserverprotocol.HurtEntityPacket;
 
 import javax.annotation.Nullable;
 import java.net.InetSocketAddress;
@@ -124,4 +127,12 @@ public class ExternalPlayer extends ServerPlayer {
                     new ClientboundSetEntityDataPacket(getId(), Collections.singletonList(getEntityData().getItem(data).value()))));
         }
     }
+
+    @Override
+    public boolean hurt(DamageSource source, float amount) {
+        externalServerConnection.send(new HurtEntityPacket(this, source, amount, CraftEventFactory.entityDamage, CraftEventFactory.blockDamage));
+        CraftEventFactory.entityDamage = null;
+        CraftEventFactory.blockDamage = null;
+        return true;
+    }
 }
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
index ff5b08a3e27643b5e3153f3f058fd0a86090b347..aabc8ed6261846cbed62ab68c5d8ab8a135a0fed 100644
--- a/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/ExternalServerPacketSerializer.java
@@ -44,6 +44,7 @@ public class ExternalServerPacketSerializer {
         addPacket(EntityRemovePacket.class, EntityRemovePacket::new);
         addPacket(PlayerActionOnEntityPacket.class, PlayerActionOnEntityPacket::new);
         addPacket(PlayerTouchEntityPacket.class, PlayerTouchEntityPacket::new);
+        addPacket(HurtEntityPacket.class, HurtEntityPacket::new);
     }
 
     private static void addPacket(Class<? extends ExternalServerPacket> clazz, Function<FriendlyByteBuf, ExternalServerPacket> deserializer) {
diff --git a/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java b/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java
new file mode 100644
index 0000000000000000000000000000000000000000..8c031e466e1b95cedc93407bc89144d1f5659e64
--- /dev/null
+++ b/src/main/java/puregero/multipaper/externalserverprotocol/HurtEntityPacket.java
@@ -0,0 +1,115 @@
+package puregero.multipaper.externalserverprotocol;
+
+import net.minecraft.core.BlockPos;
+import net.minecraft.network.FriendlyByteBuf;
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.Entity;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.bukkit.Bukkit;
+import org.bukkit.block.Block;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.block.CraftBlock;
+import org.bukkit.craftbukkit.event.CraftEventFactory;
+import puregero.multipaper.ExternalServerConnection;
+import puregero.multipaper.MultiPaper;
+import puregero.multipaper.util.DamageSourceSerializer;
+
+import java.io.*;
+import java.util.UUID;
+
+public class HurtEntityPacket extends ExternalServerPacket {
+
+    private static final Logger LOGGER = LogManager.getLogger(HurtEntityPacket.class.getSimpleName());
+
+    private final String world;
+    private final UUID uuid;
+    private final byte[] sourceBytes;
+    private final float amount;
+    private final UUID entityDamageUuid;
+    private final BlockPos blockDamagePos;
+
+    public HurtEntityPacket(Entity entity, DamageSource source, float amount, Entity entityDamage, Block blockDamage) {
+        this.world = ((ServerLevel) entity.level).convertable.getLevelId();
+        this.uuid = entity.getUUID();
+        this.amount = amount;
+        this.entityDamageUuid = entityDamage == null ? null : entityDamage.getUUID();
+        this.blockDamagePos = blockDamage == null ? null : ((CraftBlock) blockDamage).getPosition();
+
+        try {
+            ByteArrayOutputStream out = new ByteArrayOutputStream();
+            DamageSourceSerializer.serialize(source, new DataOutputStream(out));
+            sourceBytes = out.toByteArray();
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    public HurtEntityPacket(FriendlyByteBuf in) {
+        world = in.readUtf();
+        uuid = in.readUUID();
+        amount = in.readFloat();
+        sourceBytes = in.readByteArray();
+
+        if (in.readBoolean()) {
+            entityDamageUuid = in.readUUID();
+        } else {
+            entityDamageUuid = null;
+        }
+
+        if (in.readBoolean()) {
+            blockDamagePos = BlockPos.of(in.readLong());
+        } else {
+            blockDamagePos = null;
+        }
+    }
+
+    @Override
+    public void write(FriendlyByteBuf out) {
+        out.writeUtf(world);
+        out.writeUUID(uuid);
+        out.writeFloat(amount);
+        out.writeByteArray(sourceBytes);
+
+        out.writeBoolean(entityDamageUuid != null);
+        if (entityDamageUuid != null) {
+            out.writeUUID(entityDamageUuid);
+        }
+
+        out.writeBoolean(blockDamagePos != null);
+        if (blockDamagePos != null) {
+            out.writeLong(blockDamagePos.asLong());
+        }
+    }
+
+    @Override
+    public void handle(ExternalServerConnection connection) {
+        MultiPaper.runSync(() -> {
+            try {
+                ServerLevel level = ((CraftWorld) Bukkit.getWorld(world)).getHandle();
+                Entity entity = level.getEntity(uuid);
+                DamageSource source = DamageSourceSerializer.deserialize(level, new DataInputStream(new ByteArrayInputStream(sourceBytes)));
+
+                if (entity == null) {
+                    LOGGER.warn("Could not find entity " + uuid + " for damage source " + source.getMsgId());
+                    return;
+                }
+
+                Entity entityDamage = entityDamageUuid == null ? null : level.getEntity(entityDamageUuid);
+                Block blockDamage = blockDamagePos == null ? null : CraftBlock.at(level, blockDamagePos);
+
+                CraftEventFactory.entityDamage = entityDamage;
+                CraftEventFactory.blockDamage = blockDamage;
+
+                entity.hurt(source, amount);
+
+                CraftEventFactory.entityDamage = null;
+                CraftEventFactory.blockDamage = null;
+            } catch (IOException e) {
+                throw new RuntimeException(e);
+            }
+        });
+    }
+}
diff --git a/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java b/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..b231bb64f4aa5486f9af41fe3cb1719b1fc0a039
--- /dev/null
+++ b/src/main/java/puregero/multipaper/util/DamageSourceSerializer.java
@@ -0,0 +1,179 @@
+package puregero.multipaper.util;
+
+import net.minecraft.server.level.ServerLevel;
+import net.minecraft.world.damagesource.DamageSource;
+import net.minecraft.world.entity.*;
+import net.minecraft.world.entity.player.Player;
+import net.minecraft.world.entity.projectile.*;
+import net.minecraft.world.phys.Vec3;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.UUID;
+
+public class DamageSourceSerializer {
+
+    private static final Logger LOGGER = LogManager.getLogger(DamageSourceSerializer.class.getSimpleName());
+
+    /**
+     * Generate the switch statement used in deserialize
+     */
+    public static void main(String[] args) throws IllegalAccessException, InvocationTargetException {
+        StringBuilder s = new StringBuilder("return switch (msgId) {\n");
+        for (Field field : DamageSource.class.getDeclaredFields()) {
+            if (Modifier.isStatic(field.getModifiers()) && DamageSource.class.isAssignableFrom(field.getType())) {
+                String msgId = ((DamageSource) field.get(null)).getMsgId();
+                s.append("    case \"").append(msgId).append("\" -> DamageSource.").append(field.getName()).append(";\n");
+            }
+        }
+        methods: for (Method method : DamageSource.class.getDeclaredMethods()) {
+            if (Modifier.isStatic(method.getModifiers()) && DamageSource.class.isAssignableFrom(method.getReturnType())) {
+                Object[] objects = new Object[method.getParameterCount()];
+                for (int i = 0; i < method.getParameterCount(); i++) {
+                    if (!Entity.class.isAssignableFrom(method.getParameterTypes()[i])) {
+                        System.out.println("Cannot handle method " + method.getName() + " " + Arrays.toString(method.getParameterTypes()));
+                        continue methods;
+                    }
+                }
+                String msgId = ((DamageSource) method.invoke(null, objects)).getMsgId();
+                s.append("    case \"").append(msgId).append("\" -> DamageSource.").append(method.getName()).append("(");
+                for (int i = 0; i < method.getParameterCount(); i++) {
+                    if (i != 0) s.append(", ");
+                    if (method.getParameterTypes()[i] != Entity.class) {
+                        s.append("(").append(method.getParameterTypes()[i].getSimpleName()).append(") ");
+                    }
+                    s.append("entities[").append(i).append("]");
+                }
+                s.append(");\n");
+            }
+        }
+        s.append("    default -> throw new IOException(\"Unknown damage cause msgId of \" + msgId);\n");
+        s.append("};");
+        System.out.println(s);
+    }
+
+    public static void serialize(DamageSource source, DataOutputStream out) throws IOException {
+        out.writeUTF(source.getMsgId());
+        List<Entity> entities = new ArrayList<>();
+
+        if (source.getDirectEntity() != null) {
+            entities.add(source.getDirectEntity());
+        }
+
+        if (source.getEntity() != null) {
+            entities.add(source.getEntity());
+        }
+
+        out.write(entities.size());
+        for (Entity entity : entities) {
+            if (entity == null) {
+                out.writeLong(0);
+                out.writeLong(0);
+            } else {
+                out.writeLong(entity.getUUID().getMostSignificantBits());
+                out.writeLong(entity.getUUID().getLeastSignificantBits());
+            }
+        }
+
+        if (source.getSourcePosition() != null) {
+            out.writeBoolean(true);
+            out.writeDouble(source.getSourcePosition().x);
+            out.writeDouble(source.getSourcePosition().y);
+            out.writeDouble(source.getSourcePosition().z);
+        } else {
+            out.writeBoolean(false);
+        }
+    }
+
+    public static DamageSource deserialize(ServerLevel level, DataInputStream in) throws IOException {
+        String msgId = in.readUTF();
+        int entityCount = in.read();
+        Entity[] entities = new Entity[entityCount];
+        for (int i = 0; i < entities.length; i++) {
+            UUID uuid = new UUID(in.readLong(), in.readLong());
+            if (uuid.getMostSignificantBits() != 0 && uuid.getLeastSignificantBits() != 0) {
+                entities[i] = level.getEntity(uuid);
+                if (entities[i] == null) {
+                    LOGGER.warn("Unknown entity for damage source " + msgId + " index=" + i + " uuid=" + uuid);
+                }
+            }
+        }
+
+        Vec3 sourcePosition = null;
+        if (in.readBoolean()) {
+            sourcePosition = new Vec3(in.readDouble(), in.readDouble(), in.readDouble());
+        }
+
+        // Manual cases that don't work with the generated switch statement
+        if (msgId.equals("mob")) {
+            if (entities.length == 2) {
+                return level.damageSources().mobProjectile(entities[0], (LivingEntity) entities[1]);
+            } else {
+                return level.damageSources().mobAttack((LivingEntity) entities[0]);
+            }
+        } else if (msgId.equals("onFire")) {
+            if (entities.length == 2) {
+                return level.damageSources().fireball((Fireball) entities[0], entities[1]);
+            } else {
+                return level.damageSources().onFire();
+            }
+        }
+
+        // Generated switch statement
+        return switch (msgId) {
+            case "inFire" -> level.damageSources().inFire();
+            case "lightningBolt" -> level.damageSources().lightningBolt();
+//            case "onFire" -> DamageSource.ON_FIRE; // Handled above
+            case "lava" -> level.damageSources().lava();
+            case "hotFloor" -> level.damageSources().hotFloor();
+            case "inWall" -> level.damageSources().inWall();
+            case "cramming" -> level.damageSources().cramming();
+            case "drown" -> level.damageSources().drown();
+            case "starve" -> level.damageSources().starve();
+            case "cactus" -> level.damageSources().cactus();
+            case "fall" -> level.damageSources().fall();
+            case "flyIntoWall" -> level.damageSources().flyIntoWall();
+            case "outOfWorld" -> level.damageSources().outOfWorld();
+            case "generic" -> level.damageSources().generic();
+            case "magic" -> level.damageSources().magic();
+            case "wither" -> level.damageSources().wither();
+            case "anvil" -> level.damageSources().anvil(entities[0]);
+            case "fallingBlock" -> level.damageSources().fallingBlock(entities[0]);
+            case "dragonBreath" -> level.damageSources().dragonBreath();
+            case "dryout" -> level.damageSources().dryOut();
+            case "sweetBerryBush" -> level.damageSources().sweetBerryBush();
+            case "freeze" -> level.damageSources().freeze();
+            case "fallingStalactite" -> level.damageSources().fallingStalactite(entities[0]);
+            case "stalagmite" -> level.damageSources().stalagmite();
+            case "sting" -> level.damageSources().sting((LivingEntity) entities[0]);
+            case "arrow" -> level.damageSources().arrow((AbstractArrow) entities[0], entities[1]);
+            case "trident" -> level.damageSources().trident(entities[0], entities[1]);
+            case "fireworks" -> level.damageSources().fireworks((FireworkRocketEntity) entities[0], entities[1]);
+//            case "onFire" -> DamageSource.fireball((Fireball) entities[0], entities[1]); // Handled above
+            case "thrown" -> level.damageSources().thrown(entities[0], entities[1]);
+            case "thorns" -> level.damageSources().thorns(entities[0]);
+//            case "mob" -> DamageSource.mobAttack((LivingEntity) entities[0]); // Handled above
+            case "explosion" -> level.damageSources().explosion(entities[0], null);
+            case "explosion.player" -> level.damageSources().explosion(entities[0], entities[1]);
+            case "witherSkull" -> level.damageSources().witherSkull((WitherSkull) entities[0], entities[1]);
+            case "indirectMagic" -> level.damageSources().indirectMagic(entities[0], entities[1]);
+//            case "mob" -> DamageSource.indirectMobAttack(entities[0], (LivingEntity) entities[1]); // Handled above
+            case "player" -> level.damageSources().playerAttack((Player) entities[0]);
+            case "badRespawnPoint" -> level.damageSources().badRespawnPointExplosion(sourcePosition);
+            case "fireball" -> level.damageSources().fireball((Fireball) entities[0], entities[1]);
+            case "sonic_boom" -> level.damageSources().sonicBoom(entities[0]);
+            default -> throw new IOException("Unknown damage cause msgId of " + msgId);
+        };
+    }
+
+}
